# Course: CS3642 Sec 01
# Name: Brandon Dudley
# ID: 000513954
# Assignment: 1

import numpy as np

class Node:
    def __init__(self, puzzle_data, depth, prev_node):
        self.puzzle_data = puzzle_data
        i,j = np.where(puzzle_data == 0)
        self.blank_loc = i,j
        self.moves_list = [[i, j-1], [i, j+1], [i-1, j], [i+1, j]]
        self.depth = depth
        self.prev_node = prev_node
        self.f_heuristic = self.heuristic_score()
        self.manhattan_d = self.manhattan()
        self.f_heuristic_score = self.manhattan_d + self.f_heuristic
        
# Creates children
    def create_children(self):
        children_temp_list = []
        self.moves_list = self.remove_invalids()
        
        for i in self.moves_list:
            child_puzzle = self.perform_move(i)
            child = Node(child_puzzle, self.depth+1, self)
            children_temp_list.append(child)
            
        return children_temp_list
        
# Removes invalid moves from the moves list (where i,j is > 3 or negative)
    def remove_invalids(self):
        temp_list = []
        
        for x in self.moves_list:
            if x[0] != 3 and x[0] != -1 and x[1] != 3 and x[1] != -1:
                temp_list.append(x)
                
        return temp_list
    
# Moves indicies in the child node matrix based off of the legal moves
    def perform_move(self, move):
        temp_puzzle = self.puzzle_data.copy()
        
        temp_num = temp_puzzle[move[0],move[1]] # pos to move to val
        temp_puzzle[move[0],move[1]] = [0]
        temp_puzzle[self.blank_loc[0],self.blank_loc[1]] = temp_num

        return temp_puzzle
         
# Returns the number of misplaced tiles
    def heuristic_score(self):
        h = 0
        for x in range(3):
            for y in range(3):
                if npuzzle.goal_mtx[x,y] != self.puzzle_data[x,y]:
                    h+=1
        
        return h
    
#  Returns the Manhattan distance, sum of all total number of moves for each tile to be in its correct poistion
    def manhattan(self):
        sum = 0
        for x in range(3):
            for y in range(3):
                i,j = np.where(self.puzzle_data[x,y] == npuzzle.goal_mtx)
                sum += abs(i-x) + abs(j - y)
                
        return sum

class npuzzle:
    goal_mtx = np.matrix([1, 2, 3, 4, 5, 6, 7, 8, 0]).reshape(3,3)
    
    def __init__(self):
        solvable = False
        self.opened = []
        self.closed = []
        
    # Generates a random 3x3 matrix and tests its solvability, continues until a solvable matrix is generated by counting an even number of inversions
        while not solvable:
            self.init_mtx = self.randomize()
            print("Init matrix: ")
            print(self.init_mtx)
            solvable = self.isSolvable(self.invCount(self.init_mtx))
            if not solvable:
                print("Init matrix not solvable. Randomizing again... ")
            else:
                print("Solvable ")
    
# Counts total inversions 
    def invCount(self, mtx_inv):
        inv_count = 0
        arr = np.asarray(mtx_inv).reshape(-1)
        for i in range(8):
            for j in range((i+1), 9, 1):
                if(arr[j] and arr[i] and arr[i] > arr[j]):
                    inv_count+=1
        print("INV COUNT: ",inv_count)
        return inv_count

# Returns if puzzle can be solved
    def isSolvable(self, count):
        if (count % 2) == 0:
            return True

# Randomizes an array from 0 to 8 then converts it into a 3x3 matrix
    def randomize(self):
        arr = [0, 1, 2, 3, 4, 5, 6, 7, 8]
        np.random.shuffle(arr)
        mtx_rnd = np.asmatrix(arr).reshape(3,3)
        
        return mtx_rnd
    
# Solve the current puzzle
    def solver(self):
        # Initialize solvable matrix and place in the open list
        init_node = Node(self.init_mtx, 0, [])
        self.opened.append(init_node)
        
        count = 0
        print("Solving in progress ... ")
        
        while True:
            curr_node = self.opened[0]
            is_found = False
        
        # Prevents redundant children nodes from being added to the opened list thus keeping every node in the tree unique
            for x in self.closed:
                if np.array_equal(x.puzzle_data, curr_node.puzzle_data):
                    is_found = True
                    
        # Checks if the goal has been reached
            if curr_node.f_heuristic == 0:
                print("SOLVED: \n\tMoves in order:")
                
                # Creates and prints a reversed list of all nodes traversed from the initial to the goal
                list_order = []
                for x in range(curr_node.depth):
                    list_order.append(curr_node.puzzle_data)
                    curr_node = curr_node.prev_node
                    
                count_print = 1
                
                for x in reversed(list_order):
                    print(x, count_print)
                    count_print+=1
                break
            
            # If not_found is false, it means the child node is unique in the tree and can be added to the opened list
            for x in curr_node.create_children():
                if not is_found:
                    self.opened.append(x)

            # Add the current node to the closed list and delete it from the top of opened
            self.closed.append(curr_node)
            del self.opened[0]
            
            # Sort the opened list based off h-score (lowest at the top) so the current node will contain the best h-score node
            self.opened.sort(key = lambda x: x.f_heuristic_score, reverse = False)
            count+=1

            # Maximum number of iterations before the program halts
            if count > 5000:
                print("FAILED: Puzzle not solvable")
                break
                
# Main
init_puzzle = npuzzle()
init_puzzle.solver()
